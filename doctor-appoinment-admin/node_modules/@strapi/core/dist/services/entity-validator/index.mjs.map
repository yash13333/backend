{"version":3,"file":"index.mjs","sources":["../../../src/services/entity-validator/index.ts"],"sourcesContent":["/**\n * Entity validator\n * Module that will validate input data for entity creation or edition\n */\n\nimport { uniqBy, castArray, isNil, isArray, mergeWith } from 'lodash';\nimport { has, prop, isObject, isEmpty } from 'lodash/fp';\nimport strapiUtils from '@strapi/utils';\nimport type { Modules, UID, Struct, Schema } from '@strapi/types';\nimport { Validators, ValidatorMetas } from './validators';\n\ntype CreateOrUpdate = 'creation' | 'update';\n\nconst { yup, validateYupSchema } = strapiUtils;\nconst { isMediaAttribute, isScalarAttribute, getWritableAttributes } = strapiUtils.contentTypes;\nconst { ValidationError } = strapiUtils.errors;\n\ntype ID = { id: string | number };\n\ntype RelationSource = string | number | ID;\n\nexport type ComponentContext = {\n  parentContent: {\n    // The model of the parent content type that contains the current component.\n    model: Struct.Schema;\n    // The numeric id of the parent entity that contains the component.\n    id?: number;\n    // The options passed to the entity validator. From which we can extract\n    // entity dimensions such as locale and publication state.\n    options?: ValidatorContext;\n  };\n  // The path to the component within the parent content type schema.\n  pathToComponent: string[];\n  // If working with a repeatable component this contains the\n  // full data of the repeatable component in the current entity.\n  repeatableData: Modules.EntityValidator.Entity[];\n  fullDynamicZoneContent?: Schema.Attribute.Value<Schema.Attribute.DynamicZone>;\n};\n\ninterface WithComponentContext {\n  componentContext?: ComponentContext;\n}\n\ninterface ValidatorMeta<TAttribute = Schema.Attribute.AnyAttribute> extends WithComponentContext {\n  attr: TAttribute;\n  updatedAttribute: { name: string; value: any };\n}\n\ninterface ValidatorContext {\n  isDraft?: boolean;\n  locale?: string | null;\n}\n\ninterface ModelValidatorMetas extends WithComponentContext {\n  model: Struct.Schema;\n  data: Record<string, unknown>;\n  entity?: Modules.EntityValidator.Entity;\n}\n\nconst isInteger = (value: unknown): value is number => Number.isInteger(value);\n\nconst addMinMax = <\n  T extends {\n    min(value: number): T;\n    max(value: number): T;\n  },\n>(\n  validator: T,\n  {\n    attr,\n    updatedAttribute,\n  }: ValidatorMeta<Schema.Attribute.AnyAttribute & Schema.Attribute.MinMaxOption<string | number>>\n): T => {\n  let nextValidator: T = validator;\n\n  if (\n    isInteger(attr.min) &&\n    (('required' in attr && attr.required) ||\n      (Array.isArray(updatedAttribute.value) && updatedAttribute.value.length > 0))\n  ) {\n    nextValidator = nextValidator.min(attr.min);\n  }\n  if (isInteger(attr.max)) {\n    nextValidator = nextValidator.max(attr.max);\n  }\n  return nextValidator;\n};\n\nconst addRequiredValidation = (createOrUpdate: CreateOrUpdate) => {\n  return <T extends strapiUtils.yup.AnySchema>(\n    validator: T,\n    {\n      attr: { required },\n    }: ValidatorMeta<Partial<Schema.Attribute.AnyAttribute & Schema.Attribute.RequiredOption>>\n  ): T => {\n    let nextValidator = validator;\n\n    if (required) {\n      if (createOrUpdate === 'creation') {\n        nextValidator = nextValidator.notNil();\n      } else if (createOrUpdate === 'update') {\n        nextValidator = nextValidator.notNull();\n      }\n    } else {\n      nextValidator = nextValidator.nullable();\n    }\n    return nextValidator;\n  };\n};\n\nconst addDefault = (createOrUpdate: CreateOrUpdate) => {\n  return (\n    validator: strapiUtils.yup.BaseSchema,\n    { attr }: ValidatorMeta<Schema.Attribute.AnyAttribute & Schema.Attribute.DefaultOption<unknown>>\n  ) => {\n    let nextValidator = validator;\n\n    if (createOrUpdate === 'creation') {\n      if (\n        ((attr.type === 'component' && attr.repeatable) || attr.type === 'dynamiczone') &&\n        !attr.required\n      ) {\n        nextValidator = nextValidator.default([]);\n      } else {\n        nextValidator = nextValidator.default(attr.default);\n      }\n    } else {\n      nextValidator = nextValidator.default(undefined);\n    }\n\n    return nextValidator;\n  };\n};\n\nconst preventCast = (validator: strapiUtils.yup.AnySchema) =>\n  validator.transform((val, originalVal) => originalVal);\n\nconst createComponentValidator =\n  (createOrUpdate: CreateOrUpdate) =>\n  (\n    {\n      attr,\n      updatedAttribute,\n      componentContext,\n    }: ValidatorMeta<Schema.Attribute.Component<UID.Component, boolean>>,\n    { isDraft }: ValidatorContext\n  ) => {\n    const model = strapi.getModel(attr.component);\n    if (!model) {\n      throw new Error('Validation failed: Model not found');\n    }\n\n    if (attr?.repeatable) {\n      // FIXME: yup v1\n\n      let validator = yup\n        .array()\n        .of(\n          yup.lazy((item) =>\n            createModelValidator(createOrUpdate)(\n              { componentContext, model, data: item },\n              { isDraft }\n            ).notNull()\n          ) as any\n        );\n\n      validator = addRequiredValidation(createOrUpdate)(validator, {\n        attr: { required: true },\n        updatedAttribute,\n      });\n\n      if (!isDraft) {\n        validator = addMinMax(validator, { attr, updatedAttribute });\n      }\n\n      return validator;\n    }\n\n    let validator = createModelValidator(createOrUpdate)(\n      {\n        model,\n        data: updatedAttribute.value,\n        componentContext,\n      },\n      { isDraft }\n    );\n\n    validator = addRequiredValidation(createOrUpdate)(validator, {\n      attr: { required: !isDraft && attr.required },\n      updatedAttribute,\n    });\n\n    return validator;\n  };\n\nconst createDzValidator =\n  (createOrUpdate: CreateOrUpdate) =>\n  ({ attr, updatedAttribute, componentContext }: ValidatorMeta, { isDraft }: ValidatorContext) => {\n    let validator;\n\n    validator = yup.array().of(\n      yup.lazy((item) => {\n        const model = strapi.getModel(prop('__component', item));\n        const schema = yup\n          .object()\n          .shape({\n            __component: yup.string().required().oneOf(Object.keys(strapi.components)),\n          })\n          .notNull();\n\n        return model\n          ? schema.concat(\n              createModelValidator(createOrUpdate)(\n                { model, data: item, componentContext },\n                { isDraft }\n              )\n            )\n          : schema;\n      }) as any // FIXME: yup v1\n    );\n\n    validator = addRequiredValidation(createOrUpdate)(validator, {\n      attr: { required: true },\n      updatedAttribute,\n    });\n\n    if (!isDraft) {\n      validator = addMinMax(validator, { attr, updatedAttribute });\n    }\n\n    return validator;\n  };\n\nconst createRelationValidator = ({\n  updatedAttribute,\n}: ValidatorMeta<Schema.Attribute.Relation>) => {\n  let validator;\n\n  if (Array.isArray(updatedAttribute.value)) {\n    validator = yup.array().of(yup.mixed());\n  } else {\n    validator = yup.mixed();\n  }\n\n  return validator;\n};\n\nconst createScalarAttributeValidator =\n  (createOrUpdate: CreateOrUpdate) => (metas: ValidatorMeta, options: ValidatorContext) => {\n    let validator;\n\n    if (has(metas.attr.type, Validators)) {\n      validator = (Validators as any)[metas.attr.type](metas, options);\n    } else {\n      // No validators specified - fall back to mixed\n      validator = yup.mixed();\n    }\n\n    validator = addRequiredValidation(createOrUpdate)(validator, {\n      attr: { required: !options.isDraft && metas.attr.required },\n      updatedAttribute: metas.updatedAttribute,\n    });\n\n    return validator;\n  };\n\nconst createAttributeValidator =\n  (createOrUpdate: CreateOrUpdate) => (metas: ValidatorMetas, options: ValidatorContext) => {\n    let validator = yup.mixed();\n\n    if (isMediaAttribute(metas.attr)) {\n      validator = yup.mixed();\n    } else if (isScalarAttribute(metas.attr)) {\n      validator = createScalarAttributeValidator(createOrUpdate)(metas, options);\n    } else {\n      if (metas.attr.type === 'component' && metas.componentContext) {\n        // Build the path to the component within the parent content type schema.\n        const pathToComponent = [\n          ...(metas?.componentContext?.pathToComponent ?? []),\n          metas.updatedAttribute.name,\n        ];\n\n        // If working with a repeatable component, determine the repeatable data\n        // based on the component's path.\n\n        // In order to validate the repeatable within this entity we need\n        // access to the full repeatable data. In case we are validating a\n        // nested component within a repeatable.\n        // Hence why we set this up when the path to the component is only one level deep.\n        const repeatableData = (\n          metas.attr.repeatable && pathToComponent.length === 1\n            ? metas.updatedAttribute.value\n            : metas.componentContext?.repeatableData\n        ) as Modules.EntityValidator.Entity[];\n\n        const newComponentContext: ComponentContext = {\n          ...metas.componentContext,\n          pathToComponent,\n          repeatableData,\n        };\n\n        validator = createComponentValidator(createOrUpdate)(\n          {\n            componentContext: newComponentContext,\n            attr: metas.attr,\n            updatedAttribute: metas.updatedAttribute,\n          },\n          options\n        );\n      } else if (metas.attr.type === 'dynamiczone' && metas.componentContext) {\n        const newComponentContext: ComponentContext = {\n          ...metas.componentContext,\n          fullDynamicZoneContent: metas.updatedAttribute.value,\n          pathToComponent: [...metas.componentContext.pathToComponent, metas.updatedAttribute.name],\n        };\n\n        Object.assign(metas, { componentContext: newComponentContext });\n\n        validator = createDzValidator(createOrUpdate)(metas, options);\n      } else if (metas.attr.type === 'relation') {\n        validator = createRelationValidator({\n          attr: metas.attr,\n          updatedAttribute: metas.updatedAttribute,\n        });\n      }\n\n      validator = preventCast(validator);\n    }\n\n    validator = addDefault(createOrUpdate)(validator, metas);\n\n    return validator;\n  };\n\nconst createModelValidator =\n  (createOrUpdate: CreateOrUpdate) =>\n  ({ componentContext, model, data, entity }: ModelValidatorMetas, options: ValidatorContext) => {\n    const writableAttributes = model ? getWritableAttributes(model as any) : [];\n\n    const schema = writableAttributes.reduce(\n      (validators, attributeName) => {\n        const metas = {\n          attr: model.attributes[attributeName],\n          updatedAttribute: { name: attributeName, value: prop(attributeName, data) },\n          model,\n          entity,\n          componentContext,\n        };\n\n        const validator = createAttributeValidator(createOrUpdate)(metas, options);\n\n        validators[attributeName] = validator;\n\n        return validators;\n      },\n      {} as Record<string, strapiUtils.yup.BaseSchema>\n    );\n\n    return yup.object().shape(schema);\n  };\n\nconst createValidateEntity = (createOrUpdate: CreateOrUpdate) => {\n  return async <\n    TUID extends UID.ContentType,\n    TData extends Modules.EntityService.Params.Data.Input<TUID>,\n  >(\n    model: Schema.ContentType<TUID>,\n    data: TData | Partial<TData> | undefined,\n    options?: ValidatorContext,\n    entity?: Modules.EntityValidator.Entity\n  ): Promise<TData> => {\n    if (!isObject(data)) {\n      const { displayName } = model.info;\n\n      throw new ValidationError(\n        `Invalid payload submitted for the ${createOrUpdate} of an entity of type ${displayName}. Expected an object, but got ${typeof data}`\n      );\n    }\n\n    const validator = createModelValidator(createOrUpdate)(\n      {\n        model,\n        data,\n        entity,\n        componentContext: {\n          // Set up the initial component context.\n          // Keeping track of parent content type context in which a component will be used.\n          // This is necessary to validate component field constraints such as uniqueness.\n          parentContent: {\n            id: entity?.id,\n            model,\n            options,\n          },\n          pathToComponent: [],\n          repeatableData: [],\n        },\n      },\n      {\n        isDraft: options?.isDraft ?? false,\n        locale: options?.locale ?? null,\n      }\n    )\n      .test(\n        'relations-test',\n        'check that all relations exist',\n        async function relationsValidation(data) {\n          try {\n            await checkRelationsExist(buildRelationsStore({ uid: model.uid, data }));\n          } catch (e) {\n            return this.createError({\n              path: this.path,\n              message: (e instanceof ValidationError && e.message) || 'Invalid relations',\n            });\n          }\n          return true;\n        }\n      )\n      .required();\n\n    return validateYupSchema(validator, {\n      strict: false,\n      abortEarly: false,\n    })(data);\n  };\n};\n\n/**\n * Builds an object containing all the media and relations being associated with an entity\n */\nconst buildRelationsStore = <TUID extends UID.Schema>({\n  uid,\n  data,\n}: {\n  uid: TUID;\n  data: Record<string, unknown> | null;\n}): Record<string, ID[]> => {\n  if (!uid) {\n    throw new ValidationError(`Cannot build relations store: \"uid\" is undefined`);\n  }\n\n  if (isEmpty(data)) {\n    return {};\n  }\n\n  const currentModel = strapi.getModel(uid);\n\n  return Object.keys(currentModel.attributes).reduce(\n    (result, attributeName: string) => {\n      const attribute = currentModel.attributes[attributeName];\n      const value = data[attributeName];\n\n      if (isNil(value)) {\n        return result;\n      }\n\n      switch (attribute.type) {\n        case 'relation':\n        case 'media': {\n          if (\n            attribute.type === 'relation' &&\n            (attribute.relation === 'morphToMany' || attribute.relation === 'morphToOne')\n          ) {\n            // TODO: handle polymorphic relations\n            break;\n          }\n\n          const target =\n            // eslint-disable-next-line no-nested-ternary\n            attribute.type === 'media' ? 'plugin::upload.file' : attribute.target;\n          // As there are multiple formats supported for associating relations\n          // with an entity, the value here can be an: array, object or number.\n          let source: RelationSource[];\n          if (Array.isArray(value)) {\n            source = value;\n          } else if (isObject(value)) {\n            if ('connect' in value && !isNil(value.connect)) {\n              source = value.connect as RelationSource[];\n            } else if ('set' in value && !isNil(value.set)) {\n              source = value.set as RelationSource[];\n            } else {\n              source = [];\n            }\n          } else {\n            source = castArray(value as RelationSource);\n          }\n          const idArray = source.map((v) => ({\n            id: typeof v === 'object' ? v.id : v,\n          }));\n\n          // Update the relationStore to keep track of all associations being made\n          // with relations and media.\n          result[target] = result[target] || [];\n          result[target].push(...idArray);\n          break;\n        }\n        case 'component': {\n          return castArray(value).reduce((relationsStore, componentValue) => {\n            if (!attribute.component) {\n              throw new ValidationError(\n                `Cannot build relations store from component, component identifier is undefined`\n              );\n            }\n\n            return mergeWith(\n              relationsStore,\n              buildRelationsStore({\n                uid: attribute.component,\n                data: componentValue as Record<string, unknown>,\n              }),\n              (objValue, srcValue) => {\n                if (isArray(objValue)) {\n                  return objValue.concat(srcValue);\n                }\n              }\n            );\n          }, result) as Record<string, ID[]>;\n        }\n        case 'dynamiczone': {\n          return castArray(value).reduce((relationsStore, dzValue) => {\n            const value = dzValue as Record<string, unknown>;\n            if (!value.__component) {\n              throw new ValidationError(\n                `Cannot build relations store from dynamiczone, component identifier is undefined`\n              );\n            }\n\n            return mergeWith(\n              relationsStore,\n              buildRelationsStore({\n                uid: value.__component as UID.Component,\n                data: value,\n              }),\n              (objValue, srcValue) => {\n                if (isArray(objValue)) {\n                  return objValue.concat(srcValue);\n                }\n              }\n            );\n          }, result) as Record<string, ID[]>;\n        }\n        default:\n          break;\n      }\n\n      return result;\n    },\n    {} as Record<string, ID[]>\n  );\n};\n\n/**\n * Iterate through the relations store and validates that every relation or media\n * mentioned exists\n */\nconst checkRelationsExist = async (relationsStore: Record<string, ID[]> = {}) => {\n  const promises: Promise<void>[] = [];\n\n  for (const [key, value] of Object.entries(relationsStore)) {\n    const evaluate = async () => {\n      const uniqueValues = uniqBy(value, `id`);\n      const count = await strapi.db.query(key as UID.Schema).count({\n        where: {\n          id: {\n            $in: uniqueValues.map((v) => v.id),\n          },\n        },\n      });\n\n      if (count !== uniqueValues.length) {\n        throw new ValidationError(\n          `${\n            uniqueValues.length - count\n          } relation(s) of type ${key} associated with this entity do not exist`\n        );\n      }\n    };\n    promises.push(evaluate());\n  }\n\n  return Promise.all(promises);\n};\n\nconst entityValidator: Modules.EntityValidator.EntityValidator = {\n  validateEntityCreation: createValidateEntity('creation'),\n  validateEntityUpdate: createValidateEntity('update'),\n};\n\nexport default entityValidator;\n"],"names":["yup","validateYupSchema","strapiUtils","isMediaAttribute","isScalarAttribute","getWritableAttributes","contentTypes","ValidationError","errors","isInteger","value","Number","addMinMax","validator","attr","updatedAttribute","nextValidator","min","required","Array","isArray","length","max","addRequiredValidation","createOrUpdate","notNil","notNull","nullable","addDefault","type","repeatable","default","undefined","preventCast","transform","val","originalVal","createComponentValidator","componentContext","isDraft","model","strapi","getModel","component","Error","array","of","lazy","item","createModelValidator","data","createDzValidator","prop","schema","object","shape","__component","string","oneOf","Object","keys","components","concat","createRelationValidator","mixed","createScalarAttributeValidator","metas","options","has","Validators","createAttributeValidator","pathToComponent","name","repeatableData","newComponentContext","fullDynamicZoneContent","assign","entity","writableAttributes","reduce","validators","attributeName","attributes","createValidateEntity","isObject","displayName","info","parentContent","id","locale","test","relationsValidation","checkRelationsExist","buildRelationsStore","uid","e","createError","path","message","strict","abortEarly","isEmpty","currentModel","result","attribute","isNil","relation","target","source","connect","set","castArray","idArray","map","v","push","relationsStore","componentValue","mergeWith","objValue","srcValue","dzValue","promises","key","entries","evaluate","uniqueValues","uniqBy","count","db","query","where","$in","Promise","all","entityValidator","validateEntityCreation","validateEntityUpdate"],"mappings":"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"}