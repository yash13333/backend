{"version":3,"file":"reducer.js","sources":["../../../../admin/src/components/DataManagerProvider/reducer.ts"],"sourcesContent":["import { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { current } from 'immer';\nimport get from 'lodash/get';\nimport set from 'lodash/set';\n\nimport { getRelationType } from '../../utils/getRelationType';\nimport { makeUnique } from '../../utils/makeUnique';\n\nimport { retrieveComponentsFromSchema } from './utils/retrieveComponentsFromSchema';\n\nimport type { DataManagerStateType, ContentType, AttributeType, Component } from '../../types';\nimport type { Internal, Schema } from '@strapi/types';\n\ntype Target = 'component' | 'components' | 'contentType' | 'contentTypes';\n\n// TODO: Define all possible actions based on type\nexport type Action<T = any> = {\n  type: T;\n  uid?: string;\n  mainDataKey: Target;\n  schemaType: 'component' | 'contentType';\n  attributeToRemoveName?: string;\n  [key: string]: any;\n};\n\nconst DEFAULT_MODIFIED_DATA = {\n  components: {},\n  contentTypes: {},\n};\n\nconst initialState: DataManagerStateType = {\n  components: {},\n  contentTypes: {},\n  initialComponents: {},\n  initialContentTypes: {},\n  initialData: {},\n  modifiedData: {\n    ...DEFAULT_MODIFIED_DATA,\n  },\n  reservedNames: {},\n  isLoading: true,\n};\n\nconst ONE_SIDE_RELATIONS = ['oneWay', 'manyWay'];\n\nconst getOppositeRelation = (originalRelation?: Schema.Attribute.RelationKind.WithTarget) => {\n  if (originalRelation === 'manyToOne') {\n    return 'oneToMany';\n  }\n\n  if (originalRelation === 'oneToMany') {\n    return 'manyToOne';\n  }\n\n  return originalRelation;\n};\n\nconst findAttributeIndex = (schema: any, attributeToFind?: string) => {\n  return schema.schema.attributes.findIndex(\n    ({ name }: { name: string }) => name === attributeToFind\n  );\n};\n\ntype InitPayload = {\n  components: Record<string, Component>;\n  contentTypes: Record<string, ContentType>;\n  reservedNames: Record<string, string>;\n};\n\ntype AddAttributePayload = {\n  attributeToSet: Record<string, any>;\n  forTarget: Target;\n  targetUid: string;\n  shouldAddComponentToData: boolean;\n};\n\ntype AddCreateComponentToDynamicZonePayload = {\n  dynamicZoneTarget: string;\n  componentsToAdd: Internal.UID.Component[];\n};\n\ntype AddCustomFieldAttributePayload = {\n  attributeToSet: Record<string, any>;\n  forTarget: Target;\n  targetUid: string;\n};\n\ntype ChangeDynamicZoneComponentsPayload = {\n  dynamicZoneTarget: string;\n  newComponents: Internal.UID.Component[];\n};\n\ntype CreateComponentSchemaPayload = {\n  uid: string;\n  data: any;\n  componentCategory: string;\n  shouldAddComponentToData: boolean;\n};\n\ntype CreateSchemaPayload = {\n  uid: string;\n  data: any;\n};\n\ntype EditAttributePayload = {\n  attributeToSet: Record<string, any>;\n  forTarget: Target;\n  targetUid: string;\n  initialAttribute: Record<string, any>;\n};\n\ntype EditCustomFieldAttributePayload = {\n  attributeToSet: Record<string, any>;\n  forTarget: Target;\n  targetUid: string;\n  initialAttribute: Record<string, any>;\n};\n\ntype RemoveComponentFromDynamicZonePayload = {\n  dzName: string;\n  componentToRemoveIndex: number;\n};\n\ntype RemoveFieldPayload = {\n  mainDataKey: Target;\n  attributeToRemoveName: string;\n};\n\ntype RemoveFieldFromDisplayedComponentPayload = {\n  attributeToRemoveName: string;\n  componentUid: string;\n};\n\ntype SetModifiedDataPayload = {\n  schemaToSet: Partial<DataManagerStateType['modifiedData']>;\n  hasJustCreatedSchema: boolean;\n};\n\ntype UpdateSchemaPayload =\n  | {\n      data: Record<string, any>;\n      schemaType: 'component';\n      uid: string;\n    }\n  | {\n      data: Record<string, any>;\n      schemaType: 'contentType';\n    };\n\nconst slice = createSlice({\n  name: 'data-manager',\n  initialState,\n  reducers: {\n    init: (state, action: PayloadAction<InitPayload>) => {\n      const { components, contentTypes, reservedNames } = action.payload;\n\n      state.components = components;\n      state.initialComponents = components;\n      state.initialContentTypes = contentTypes;\n      state.contentTypes = contentTypes;\n      state.reservedNames = reservedNames;\n      state.isLoading = false;\n\n      state.modifiedData = {\n        ...DEFAULT_MODIFIED_DATA,\n        component: state.modifiedData.component\n          ? components[state.modifiedData.component.uid]\n          : undefined,\n        contentType: state.modifiedData.contentType\n          ? contentTypes[state.modifiedData.contentType.uid]\n          : undefined,\n        components: state.modifiedData.components\n          ? Object.keys(state.modifiedData.components).reduce(\n              (acc, key) => {\n                acc[key] = components[key];\n                return acc;\n              },\n              {} as Record<string, Component>\n            )\n          : {},\n        contentTypes: state.modifiedData.contentTypes\n          ? Object.keys(state.modifiedData.contentTypes).reduce(\n              (acc, key) => {\n                acc[key] = contentTypes[key];\n                return acc;\n              },\n              {} as Record<string, ContentType>\n            )\n          : {},\n      };\n      state.initialData = state.modifiedData;\n    },\n    addAttribute: (state, action: PayloadAction<AddAttributePayload>) => {\n      const { attributeToSet, forTarget, targetUid, shouldAddComponentToData } = action.payload;\n      const { name, ...rest } = attributeToSet;\n\n      delete rest.createComponent;\n\n      const pathToDataToEdit = ['component', 'contentType'].includes(forTarget)\n        ? [forTarget]\n        : [forTarget, targetUid];\n\n      const currentAttributes = get(\n        state,\n        ['modifiedData', ...pathToDataToEdit, 'schema', 'attributes'],\n        []\n      ).slice();\n\n      // Add the createdAttribute\n      const updatedAttributes = [...currentAttributes, { ...rest, name }];\n\n      set(state, ['modifiedData', ...pathToDataToEdit, 'schema', 'attributes'], updatedAttributes);\n\n      if (shouldAddComponentToData) {\n        const componentToAddUID = rest.component;\n        const componentToAdd = state.components[componentToAddUID];\n        const isTemporaryComponent = componentToAdd?.isTemporary;\n        const hasComponentAlreadyBeenAdded =\n          state.modifiedData.components?.[componentToAddUID] !== undefined;\n\n        if (isTemporaryComponent || hasComponentAlreadyBeenAdded) {\n          return;\n        }\n\n        // Initialize modifiedData.components if it is undefined\n        if (!state.modifiedData.components) {\n          state.modifiedData.components = {};\n        }\n\n        // Add the added component to the modifiedData.components\n        state.modifiedData.components[componentToAddUID] = componentToAdd;\n\n        const nestedComponents = retrieveComponentsFromSchema(\n          componentToAdd.schema.attributes as AttributeType[],\n          state.components\n        );\n\n        // We dont' need to set the already added components otherwise all modifications will be lost so we need to only add the not modified ones\n        const nestedComponentsToAddInModifiedData = nestedComponents.filter(\n          (compoUID: Internal.UID.Component) => {\n            return get(state, ['modifiedData', 'components', compoUID]) === undefined;\n          }\n        );\n\n        nestedComponentsToAddInModifiedData.forEach((compoUID: Internal.UID.Component) => {\n          const compoSchema = get(state, ['components', compoUID], {}) as Component;\n          const isTemporary = compoSchema.isTemporary || false;\n\n          // If the nested component has not been saved we don't need to add them as they are already in the state\n          if (!isTemporary) {\n            if (!state.modifiedData.components) {\n              state.modifiedData.components = {};\n            }\n\n            state.modifiedData.components[compoUID] = compoSchema;\n          }\n        });\n\n        return;\n      }\n\n      const isCreatingRelationAttribute = rest.type === 'relation';\n\n      if (isCreatingRelationAttribute) {\n        const target = rest.target;\n        const targetAttribute = rest.targetAttribute || null;\n        const relation = rest.relation;\n        const relationType = getRelationType(relation, targetAttribute);\n        const currentUid = get(state, ['modifiedData', ...pathToDataToEdit, 'uid']);\n\n        // When the user in creating a relation with the same content type we need to create another attribute\n        // that is the opposite of the created one\n        if (\n          rest.type === 'relation' &&\n          relationType !== 'oneWay' &&\n          relationType !== 'manyWay' &&\n          target === currentUid\n        ) {\n          const oppositeAttribute = {\n            name: targetAttribute,\n            relation: getOppositeRelation(relationType),\n            target,\n            targetAttribute: name,\n            type: 'relation',\n          } as AttributeType;\n\n          if (rest.private) {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            oppositeAttribute.private = rest.private;\n          }\n\n          const attributesToSet = [...updatedAttributes, oppositeAttribute];\n\n          set(\n            state,\n            ['modifiedData', ...pathToDataToEdit, 'schema', 'attributes'],\n            attributesToSet\n          );\n        }\n      }\n    },\n    addCreatedComponentToDynamicZone: (\n      state,\n      action: PayloadAction<AddCreateComponentToDynamicZonePayload>\n    ) => {\n      const { dynamicZoneTarget, componentsToAdd } = action.payload;\n\n      const dzAttributeIndex = findAttributeIndex(\n        state.modifiedData.contentType,\n        dynamicZoneTarget\n      );\n\n      componentsToAdd.forEach((componentUid: Internal.UID.Component) => {\n        if (!state.modifiedData.contentType) {\n          return;\n        }\n\n        if (!state.modifiedData.contentType.schema.attributes[dzAttributeIndex].components) {\n          state.modifiedData.contentType.schema.attributes[dzAttributeIndex].components = [];\n        }\n        state.modifiedData.contentType.schema.attributes[dzAttributeIndex].components.push(\n          componentUid\n        );\n      });\n    },\n    addCustomFieldAttribute: (state, action: PayloadAction<AddCustomFieldAttributePayload>) => {\n      const { attributeToSet, forTarget, targetUid } = action.payload;\n      const { name, ...rest } = attributeToSet;\n\n      const pathToDataToEdit = ['component', 'contentType'].includes(forTarget)\n        ? [forTarget]\n        : [forTarget, targetUid];\n\n      const currentAttributes = get(\n        state,\n        ['modifiedData', ...pathToDataToEdit, 'schema', 'attributes'],\n        []\n      ).slice();\n\n      // Add the createdAttribute\n      const updatedAttributes = [...currentAttributes, { ...rest, name }];\n\n      set(state, ['modifiedData', ...pathToDataToEdit, 'schema', 'attributes'], updatedAttributes);\n    },\n    changeDynamicZoneComponents: (\n      state,\n      action: PayloadAction<ChangeDynamicZoneComponentsPayload>\n    ) => {\n      const { dynamicZoneTarget, newComponents } = action.payload;\n\n      const dzAttributeIndex = findAttributeIndex(\n        state.modifiedData.contentType,\n        dynamicZoneTarget\n      );\n\n      const currentDZComponents =\n        (state.modifiedData.contentType?.schema.attributes[dzAttributeIndex]).components;\n\n      const updatedComponents = makeUnique([...currentDZComponents, ...newComponents]);\n\n      (state.modifiedData.contentType?.schema.attributes[dzAttributeIndex]).components =\n        updatedComponents;\n\n      // Retrieve all the components that needs to be added to the modifiedData.components\n      const nestedComponents = retrieveComponentsFromSchema(\n        current(state.modifiedData.contentType?.schema.attributes),\n        state.components\n      );\n\n      // We dont' need to set the already added components otherwise all modifications will be lost so we need to only add the not modified ones\n      const nestedComponentsToAddInModifiedData = nestedComponents.filter((compoUID) => {\n        return get(state, ['modifiedData', 'components', compoUID]) === undefined;\n      });\n\n      nestedComponentsToAddInModifiedData.forEach((compoUID: Internal.UID.Component) => {\n        const compoSchema = get(state, ['components', compoUID], {}) as Component;\n        const isTemporary = compoSchema.isTemporary || false;\n\n        // If the nested component has not been saved we don't need to add them as they are already in the state\n        if (!isTemporary) {\n          if (!state.modifiedData.components) {\n            state.modifiedData.components = {};\n          }\n          state.modifiedData.components[compoUID] = compoSchema;\n        }\n      });\n    },\n    createComponentSchema: (state, action: PayloadAction<CreateComponentSchemaPayload>) => {\n      const { uid, data, componentCategory, shouldAddComponentToData } = action.payload;\n\n      const newSchema: Component = {\n        uid: uid as Internal.UID.Component,\n        isTemporary: true,\n        category: componentCategory,\n        schema: {\n          ...data,\n          attributes: [],\n        },\n      };\n\n      state.components[uid as string] = newSchema;\n\n      if (shouldAddComponentToData) {\n        state.modifiedData.components[uid as string] = newSchema;\n      }\n    },\n    createSchema: (state, action: PayloadAction<CreateSchemaPayload>) => {\n      const { uid, data } = action.payload;\n\n      const newSchema: ContentType = {\n        uid: uid as Internal.UID.ContentType,\n        isTemporary: true,\n        schema: {\n          ...data,\n          attributes: [],\n        },\n      };\n\n      state.contentTypes[uid] = newSchema;\n    },\n    editAttribute: (state, action: PayloadAction<EditAttributePayload>) => {\n      const { attributeToSet, forTarget, targetUid, initialAttribute } = action.payload;\n      const { name, ...rest } = attributeToSet;\n\n      const initialAttributeName = initialAttribute.name;\n      const pathToDataToEdit = ['component', 'contentType'].includes(forTarget)\n        ? [forTarget]\n        : [forTarget, targetUid];\n\n      const initialAttributeIndex = findAttributeIndex(\n        get(state, ['modifiedData', ...pathToDataToEdit]),\n        initialAttributeName\n      );\n\n      const isEditingRelation = rest.type === 'relation';\n\n      if (!isEditingRelation) {\n        set(\n          state,\n          ['modifiedData', ...pathToDataToEdit, 'schema', 'attributes', initialAttributeIndex],\n          attributeToSet\n        );\n\n        return;\n      }\n\n      const updatedAttributes: AttributeType[] = get(state, [\n        'modifiedData',\n        ...pathToDataToEdit,\n        'schema',\n        'attributes',\n      ]).slice();\n\n      // First create the current relation attribute updated\n      const toSet = {\n        name,\n        relation: rest.relation,\n        target: rest.target,\n        targetAttribute: rest.targetAttribute,\n        type: 'relation',\n      } as AttributeType;\n\n      if (rest.private) {\n        toSet.private = rest.private;\n      }\n\n      if (rest.pluginOptions) {\n        toSet.pluginOptions = rest.pluginOptions;\n      }\n\n      const currentAttributeIndex = updatedAttributes.findIndex((value: AttributeType) => {\n        return value.name !== undefined && value.name === initialAttribute.name;\n      });\n\n      // First set it in the updatedAttributes\n      if (currentAttributeIndex !== -1) {\n        updatedAttributes.splice(currentAttributeIndex, 1, toSet);\n      }\n\n      let oppositeAttributeNameToRemove: string | null = null;\n      let oppositeAttributeNameToUpdate: string | null = null;\n      let oppositeAttributeToCreate: AttributeType | null = null;\n      let initialOppositeAttribute = null;\n\n      const currentUid = get(state, ['modifiedData', ...pathToDataToEdit, 'uid']);\n      const didChangeTargetRelation = initialAttribute.target !== rest.target;\n      const didCreateInternalRelation = rest.target === currentUid;\n      const relationType = getRelationType(rest.relation, rest.targetAttribute);\n      const initialRelationType = getRelationType(\n        initialAttribute.relation,\n        initialAttribute.targetAttribute\n      );\n      const hadInternalRelation = initialAttribute.target === currentUid;\n      const didChangeRelationType = initialRelationType !== relationType;\n      const shouldRemoveOppositeAttributeBecauseOfTargetChange =\n        didChangeTargetRelation &&\n        !didCreateInternalRelation &&\n        hadInternalRelation &&\n        isEditingRelation;\n      const shouldRemoveOppositeAttributeBecauseOfRelationTypeChange =\n        didChangeRelationType &&\n        hadInternalRelation &&\n        ['oneWay', 'manyWay'].includes(relationType!) &&\n        isEditingRelation;\n      const shouldUpdateOppositeAttributeBecauseOfRelationTypeChange =\n        !ONE_SIDE_RELATIONS.includes(initialRelationType!) &&\n        !ONE_SIDE_RELATIONS.includes(relationType!) &&\n        hadInternalRelation &&\n        didCreateInternalRelation &&\n        isEditingRelation;\n      const shouldCreateOppositeAttributeBecauseOfRelationTypeChange =\n        ONE_SIDE_RELATIONS.includes(initialRelationType!) &&\n        !ONE_SIDE_RELATIONS.includes(relationType!) &&\n        hadInternalRelation &&\n        didCreateInternalRelation &&\n        isEditingRelation;\n      const shouldCreateOppositeAttributeBecauseOfTargetChange =\n        didChangeTargetRelation &&\n        didCreateInternalRelation &&\n        !ONE_SIDE_RELATIONS.includes(relationType!);\n\n      // Store opposite attribute name to remove at the end of the loop\n      if (\n        shouldRemoveOppositeAttributeBecauseOfTargetChange ||\n        shouldRemoveOppositeAttributeBecauseOfRelationTypeChange\n      ) {\n        oppositeAttributeNameToRemove = initialAttribute.targetAttribute;\n      }\n\n      // In case of oneWay or manyWay relation there isn't an opposite attribute\n      if (oppositeAttributeNameToRemove) {\n        const indexToRemove = updatedAttributes.findIndex(\n          (value) => value.name === oppositeAttributeNameToRemove\n        );\n\n        updatedAttributes.splice(indexToRemove, 1);\n      }\n\n      // In order to preserve plugin options need to get the initial opposite attribute settings\n      if (!shouldRemoveOppositeAttributeBecauseOfTargetChange) {\n        const initialTargetContentType = get(state, [\n          'initialContentTypes',\n          initialAttribute.target,\n        ]);\n\n        if (initialTargetContentType) {\n          const oppositeAttributeIndex = findAttributeIndex(\n            initialTargetContentType,\n            initialAttribute.targetAttribute\n          );\n\n          initialOppositeAttribute = get(state, [\n            'initialContentTypes',\n            initialAttribute.target,\n            'schema',\n            'attributes',\n            oppositeAttributeIndex,\n          ]);\n        }\n      }\n\n      // Create the opposite attribute\n      if (\n        shouldCreateOppositeAttributeBecauseOfRelationTypeChange ||\n        shouldCreateOppositeAttributeBecauseOfTargetChange\n      ) {\n        oppositeAttributeToCreate = {\n          name: rest.targetAttribute,\n          relation: getOppositeRelation(relationType),\n          target: rest.target,\n          targetAttribute: name,\n          type: 'relation',\n        } as AttributeType;\n\n        if (rest.private) {\n          oppositeAttributeToCreate.private = rest.private;\n        }\n\n        if (initialOppositeAttribute && initialOppositeAttribute.pluginOptions) {\n          oppositeAttributeToCreate.pluginOptions = initialOppositeAttribute.pluginOptions;\n        }\n\n        const indexOfInitialAttribute = updatedAttributes.findIndex(\n          ({ name }) => name === initialAttribute.name\n        );\n        const indexOfUpdatedAttribute = updatedAttributes.findIndex(\n          ({ name: attrName }) => name === attrName\n        );\n\n        const indexToInsert =\n          (indexOfInitialAttribute === -1 ? indexOfUpdatedAttribute : indexOfInitialAttribute) + 1;\n\n        updatedAttributes.splice(indexToInsert, 0, oppositeAttributeToCreate);\n      }\n\n      if (shouldUpdateOppositeAttributeBecauseOfRelationTypeChange) {\n        oppositeAttributeNameToUpdate = initialAttribute.targetAttribute;\n\n        oppositeAttributeToCreate = {\n          name: rest.targetAttribute,\n          relation: getOppositeRelation(relationType),\n          target: rest.target,\n          targetAttribute: name,\n          type: 'relation',\n        } as AttributeType;\n\n        if (rest.private) {\n          oppositeAttributeToCreate.private = rest.private;\n        }\n\n        if (initialOppositeAttribute && initialOppositeAttribute.pluginOptions) {\n          oppositeAttributeToCreate.pluginOptions = initialOppositeAttribute.pluginOptions;\n        }\n\n        if (oppositeAttributeNameToUpdate) {\n          const indexToUpdate = updatedAttributes.findIndex(\n            ({ name }) => name === oppositeAttributeNameToUpdate\n          );\n\n          updatedAttributes.splice(indexToUpdate, 1, oppositeAttributeToCreate);\n        }\n      }\n\n      set(state, ['modifiedData', ...pathToDataToEdit, 'schema', 'attributes'], updatedAttributes);\n    },\n    editCustomFieldAttribute: (state, action: PayloadAction<EditCustomFieldAttributePayload>) => {\n      const { forTarget, targetUid, initialAttribute, attributeToSet } = action.payload;\n\n      const initialAttributeName = initialAttribute.name;\n      const pathToDataToEdit = ['component', 'contentType'].includes(forTarget)\n        ? [forTarget]\n        : [forTarget, targetUid];\n\n      const initialAttributeIndex = findAttributeIndex(\n        get(state, ['modifiedData', ...pathToDataToEdit]),\n        initialAttributeName\n      );\n\n      set(\n        state,\n        ['modifiedData', ...pathToDataToEdit, 'schema', 'attributes', initialAttributeIndex],\n        attributeToSet\n      );\n    },\n    updateInitialState: (state) => {\n      state.initialData = state.modifiedData;\n    },\n    deleteNotSavedType: (state) => {\n      // Doing so will also reset the modified and the initial data\n      state.contentTypes = state.initialContentTypes;\n      state.components = state.initialComponents;\n    },\n    reloadPlugin: () => {\n      return initialState;\n    },\n    removeComponentFromDynamicZone: (\n      state,\n      action: PayloadAction<RemoveComponentFromDynamicZonePayload>\n    ) => {\n      const { dzName, componentToRemoveIndex } = action.payload;\n\n      const dzAttributeIndex = findAttributeIndex(state.modifiedData.contentType, dzName);\n\n      if (state.modifiedData.contentType) {\n        state.modifiedData.contentType.schema.attributes[dzAttributeIndex].components.splice(\n          componentToRemoveIndex,\n          1\n        );\n      }\n    },\n    removeField: (state, action: PayloadAction<RemoveFieldPayload>) => {\n      const { mainDataKey, attributeToRemoveName } = action.payload;\n      const pathToAttributes = ['modifiedData', mainDataKey, 'schema', 'attributes'];\n      const attributeToRemoveIndex = findAttributeIndex(\n        state.modifiedData[mainDataKey],\n        attributeToRemoveName\n      );\n\n      const pathToAttributeToRemove = [...pathToAttributes, attributeToRemoveIndex];\n      const attributeToRemoveData = get(state, pathToAttributeToRemove);\n      const isRemovingRelationAttribute = attributeToRemoveData.type === 'relation';\n      // Only content types can have relations with themselves since\n      // components can only have oneWay or manyWay relations\n      const canTheAttributeToRemoveHaveARelationWithItself = mainDataKey === 'contentType';\n\n      if (isRemovingRelationAttribute && canTheAttributeToRemoveHaveARelationWithItself) {\n        const { target, relation, targetAttribute } = attributeToRemoveData;\n        const relationType = getRelationType(relation, targetAttribute);\n\n        const uid = state.modifiedData.contentType?.uid;\n        const shouldRemoveOppositeAttribute =\n          target === uid && !ONE_SIDE_RELATIONS.includes(relationType!);\n\n        if (shouldRemoveOppositeAttribute) {\n          const attributes: AttributeType[] =\n            state.modifiedData[mainDataKey]?.schema.attributes.slice();\n          const nextAttributes = attributes.filter((attribute) => {\n            if (attribute.name === attributeToRemoveName) {\n              return false;\n            }\n\n            if (attribute.target === uid && attribute.targetAttribute === attributeToRemoveName) {\n              return false;\n            }\n\n            return true;\n          });\n\n          const schema = state.modifiedData[mainDataKey];\n          if (schema) {\n            schema.schema.attributes = nextAttributes;\n          }\n\n          return;\n        }\n      }\n\n      // Find all uid fields that have the targetField set to the field we are removing\n\n      const uidFieldsToUpdate: string[] = state.modifiedData[\n        mainDataKey\n      ]!.schema.attributes.slice().reduce((acc: string[], current: AttributeType) => {\n        if (current.type !== 'uid') {\n          return acc;\n        }\n\n        if (current.targetField !== attributeToRemoveName) {\n          return acc;\n        }\n\n        acc.push(current.name as string);\n\n        return acc;\n      }, []);\n\n      uidFieldsToUpdate.forEach((fieldName) => {\n        const fieldIndex = findAttributeIndex(state.modifiedData[mainDataKey], fieldName);\n\n        delete state.modifiedData[mainDataKey]?.schema.attributes[fieldIndex].targetField;\n      });\n\n      state.modifiedData[mainDataKey]?.schema.attributes.splice(attributeToRemoveIndex, 1);\n    },\n    removeFieldFromDisplayedComponent: (\n      state,\n      action: PayloadAction<RemoveFieldFromDisplayedComponentPayload>\n    ) => {\n      const { attributeToRemoveName, componentUid } = action.payload;\n\n      const attributeToRemoveIndex = findAttributeIndex(\n        state.modifiedData.components?.[componentUid],\n        attributeToRemoveName\n      );\n\n      state.modifiedData.components?.[componentUid]?.schema?.attributes?.splice(\n        attributeToRemoveIndex,\n        1\n      );\n    },\n    setModifiedData: (state, action: PayloadAction<SetModifiedDataPayload>) => {\n      const { schemaToSet, hasJustCreatedSchema } = action.payload;\n\n      const schema = {\n        ...DEFAULT_MODIFIED_DATA,\n        ...schemaToSet,\n      };\n\n      state.initialData = schema;\n      state.modifiedData = schema;\n\n      // Reset the state with the initial data\n      // All created components and content types will be lost\n      if (!hasJustCreatedSchema) {\n        state.components = state.initialComponents;\n        state.contentTypes = state.initialContentTypes;\n      }\n    },\n    updateSchema: (state, action: PayloadAction<UpdateSchemaPayload>) => {\n      const { data, schemaType } = action.payload;\n\n      const schema = state.modifiedData[schemaType];\n      if (!schema) {\n        return;\n      }\n\n      schema.schema.displayName = data.displayName;\n\n      if (schemaType === 'component') {\n        const { uid } = action.payload;\n\n        schema.category = data.category;\n        schema.schema.icon = data.icon;\n        const addedComponent = current(schema);\n        state.components[uid] = addedComponent as Component;\n      } else {\n        schema.schema.kind = data.kind;\n      }\n    },\n  },\n});\n\nexport const { reducer, actions } = slice;\nexport { initialState };\n"],"names":["DEFAULT_MODIFIED_DATA","components","contentTypes","initialState","initialComponents","initialContentTypes","initialData","modifiedData","reservedNames","isLoading","ONE_SIDE_RELATIONS","getOppositeRelation","originalRelation","findAttributeIndex","schema","attributeToFind","attributes","findIndex","name","slice","createSlice","reducers","init","state","action","payload","component","uid","undefined","contentType","Object","keys","reduce","acc","key","addAttribute","attributeToSet","forTarget","targetUid","shouldAddComponentToData","rest","createComponent","pathToDataToEdit","includes","currentAttributes","get","updatedAttributes","set","componentToAddUID","componentToAdd","isTemporaryComponent","isTemporary","hasComponentAlreadyBeenAdded","nestedComponents","retrieveComponentsFromSchema","nestedComponentsToAddInModifiedData","filter","compoUID","forEach","compoSchema","isCreatingRelationAttribute","type","target","targetAttribute","relation","relationType","getRelationType","currentUid","oppositeAttribute","private","attributesToSet","addCreatedComponentToDynamicZone","dynamicZoneTarget","componentsToAdd","dzAttributeIndex","componentUid","push","addCustomFieldAttribute","changeDynamicZoneComponents","newComponents","currentDZComponents","updatedComponents","makeUnique","current","createComponentSchema","data","componentCategory","newSchema","category","createSchema","editAttribute","initialAttribute","initialAttributeName","initialAttributeIndex","isEditingRelation","toSet","pluginOptions","currentAttributeIndex","value","splice","oppositeAttributeNameToRemove","oppositeAttributeNameToUpdate","oppositeAttributeToCreate","initialOppositeAttribute","didChangeTargetRelation","didCreateInternalRelation","initialRelationType","hadInternalRelation","didChangeRelationType","shouldRemoveOppositeAttributeBecauseOfTargetChange","shouldRemoveOppositeAttributeBecauseOfRelationTypeChange","shouldUpdateOppositeAttributeBecauseOfRelationTypeChange","shouldCreateOppositeAttributeBecauseOfRelationTypeChange","shouldCreateOppositeAttributeBecauseOfTargetChange","indexToRemove","initialTargetContentType","oppositeAttributeIndex","indexOfInitialAttribute","indexOfUpdatedAttribute","attrName","indexToInsert","indexToUpdate","editCustomFieldAttribute","updateInitialState","deleteNotSavedType","reloadPlugin","removeComponentFromDynamicZone","dzName","componentToRemoveIndex","removeField","mainDataKey","attributeToRemoveName","pathToAttributes","attributeToRemoveIndex","pathToAttributeToRemove","attributeToRemoveData","isRemovingRelationAttribute","canTheAttributeToRemoveHaveARelationWithItself","shouldRemoveOppositeAttribute","nextAttributes","attribute","uidFieldsToUpdate","targetField","fieldName","fieldIndex","removeFieldFromDisplayedComponent","setModifiedData","schemaToSet","hasJustCreatedSchema","updateSchema","schemaType","displayName","icon","addedComponent","kind","reducer","actions"],"mappings":"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"}