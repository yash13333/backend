'use strict';

var React = require('react');
var strapiAdmin = require('@strapi/admin/strapi-admin');
var designSystem = require('@strapi/design-system');
var isEqual = require('lodash/isEqual');
var reactIntl = require('react-intl');
var useDataManager = require('../../hooks/useDataManager.js');
var useFormModalNavigation = require('../../hooks/useFormModalNavigation.js');
var pluginId = require('../../pluginId.js');
var getTrad = require('../../utils/getTrad.js');

const useContentTypeBuilderMenu = ()=>{
    const { components, componentsGroupedByCategory, contentTypes, isInDevelopmentMode, sortedContentTypesList, modifiedData, initialData } = useDataManager.useDataManager();
    const { toggleNotification } = strapiAdmin.useNotification();
    const { formatMessage } = reactIntl.useIntl();
    const { trackUsage } = strapiAdmin.useTracking();
    const [searchValue, setSearchValue] = React.useState('');
    const { onOpenModalCreateSchema, onOpenModalEditCategory } = useFormModalNavigation.useFormModalNavigation();
    const { locale } = reactIntl.useIntl();
    const { startsWith } = designSystem.useFilter(locale, {
        sensitivity: 'base'
    });
    const formatter = designSystem.useCollator(locale, {
        sensitivity: 'base'
    });
    // TODO: Allow creating mutliple schemas in parallel
    const canOpenModalCreateCTorComponent = !Object.keys(contentTypes).some((ct)=>contentTypes[ct].isTemporary === true) && !Object.keys(components).some((component)=>components[component].isTemporary === true) && isEqual(modifiedData, initialData);
    const handleClickOpenModalCreateCollectionType = ()=>{
        if (canOpenModalCreateCTorComponent) {
            // TODO: Review tracking with product
            trackUsage(`willCreateContentType`);
            const nextState = {
                modalType: 'contentType',
                kind: 'collectionType',
                actionType: 'create',
                forTarget: 'contentType'
            };
            onOpenModalCreateSchema(nextState);
        } else {
            toggleNotificationCannotCreateSchema();
        }
    };
    const handleClickOpenModalCreateSingleType = ()=>{
        if (canOpenModalCreateCTorComponent) {
            trackUsage(`willCreateSingleType`);
            const nextState = {
                modalType: 'contentType',
                kind: 'singleType',
                actionType: 'create',
                forTarget: 'contentType'
            };
            onOpenModalCreateSchema(nextState);
        } else {
            toggleNotificationCannotCreateSchema();
        }
    };
    const handleClickOpenModalCreateComponent = ()=>{
        if (canOpenModalCreateCTorComponent) {
            trackUsage('willCreateComponent');
            const nextState = {
                modalType: 'component',
                kind: null,
                actionType: 'create',
                forTarget: 'component'
            };
            onOpenModalCreateSchema(nextState);
        } else {
            toggleNotificationCannotCreateSchema();
        }
    };
    const toggleNotificationCannotCreateSchema = ()=>{
        toggleNotification({
            type: 'info',
            message: formatMessage({
                id: getTrad.getTrad('notification.info.creating.notSaved'),
                defaultMessage: 'Please save your work before creating a new collection type or component'
            })
        });
    };
    const componentsData = Object.entries(componentsGroupedByCategory).map(([category, components])=>({
            name: category,
            title: category,
            isEditable: isInDevelopmentMode,
            // TODO: re-add functionality to edit category name
            onClickEdit (e, data) {
                e.stopPropagation();
                if (canOpenModalCreateCTorComponent) {
                    onOpenModalEditCategory(data.name);
                } else {
                    toggleNotificationCannotCreateSchema();
                }
            },
            links: components.map((component)=>({
                    name: component.uid,
                    to: `/plugins/${pluginId.pluginId}/component-categories/${category}/${component.uid}`,
                    title: component.schema.displayName
                })).sort((a, b)=>formatter.compare(a.title, b.title))
        })).sort((a, b)=>formatter.compare(a.title, b.title));
    const displayedContentTypes = sortedContentTypesList.filter((obj)=>obj.visible);
    const data = [
        {
            name: 'models',
            title: {
                id: `${getTrad.getTrad('menu.section.models.name')}`,
                defaultMessage: 'Collection Types'
            },
            customLink: isInDevelopmentMode && {
                id: `${getTrad.getTrad('button.model.create')}`,
                defaultMessage: 'Create new collection type',
                onClick: handleClickOpenModalCreateCollectionType
            },
            links: displayedContentTypes.filter((contentType)=>contentType.kind === 'collectionType')
        },
        {
            name: 'singleTypes',
            title: {
                id: `${getTrad.getTrad('menu.section.single-types.name')}`,
                defaultMessage: 'Single Types'
            },
            customLink: isInDevelopmentMode && {
                id: `${getTrad.getTrad('button.single-types.create')}`,
                defaultMessage: 'Create new single type',
                onClick: handleClickOpenModalCreateSingleType
            },
            links: displayedContentTypes.filter((singleType)=>singleType.kind === 'singleType')
        },
        {
            name: 'components',
            title: {
                id: `${getTrad.getTrad('menu.section.components.name')}`,
                defaultMessage: 'Components'
            },
            customLink: isInDevelopmentMode && {
                id: `${getTrad.getTrad('button.component.create')}`,
                defaultMessage: 'Create a new component',
                onClick: handleClickOpenModalCreateComponent
            },
            links: componentsData
        }
    ].map((section)=>{
        const hasChild = section.links.some((l)=>Array.isArray(l.links));
        if (hasChild) {
            let filteredLinksCount = 0;
            return {
                ...section,
                links: section.links.map((link)=>{
                    const filteredLinks = link.links.filter((link)=>startsWith(link.title, searchValue));
                    if (filteredLinks.length === 0) {
                        return null;
                    }
                    filteredLinksCount += filteredLinks.length;
                    return {
                        ...link,
                        links: filteredLinks.sort((a, b)=>formatter.compare(a.title, b.title))
                    };
                }).filter(Boolean),
                linksCount: filteredLinksCount
            };
        }
        const filteredLinks = section.links.filter((link)=>startsWith(link.title, searchValue)).sort((a, b)=>formatter.compare(a.title, b.title));
        return {
            ...section,
            links: filteredLinks,
            linksCount: filteredLinks.length
        };
    });
    return {
        menu: data,
        search: {
            value: searchValue,
            onChange: setSearchValue,
            clear: ()=>setSearchValue('')
        }
    };
};

exports.useContentTypeBuilderMenu = useContentTypeBuilderMenu;
//# sourceMappingURL=useContentTypeBuilderMenu.js.map
